
#include <map>
#include <string>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <algorithm>

#include "gpmatlan.h"
#include "whodun_cigfq.h"
#include "whodun_bamfa.h"
#include "whodun_datread.h"
#include "whodun_probutil.h"
#include "whodun_align_affinepd.h"

/**A sam entry to work over, and the stuff to work with.*/
typedef struct{
	/**The entry to work over.*/
	LiveSAMFileReader* samFil;
	/**The program arguments.*/
	ParseArgs* pargs;
	/**The main info.*/
	ProblemLoadSetup* mainInfo;
	/**The space for waiting pairs.*/
	std::map< std::string, WaitingPairedEntry >* waitingPairs;
	/**The stream to write to.*/
	std::ostream* toDump;
	/**The stream to write errors to.*/
	std::ostream* errDump;
} SAMEntryContext;

/**The setup and result of an alignment.*/
class RealignSetupResult{
public:
	/**The sam entry.*/
	SAMEntryContext* sec;
	/**The full cost function for the reference.*/
	PositionDependentAlignCostKDNode* fullCF;
	/**The full reference sequence.*/
	std::string* fullRefSeq;
	/**The low relevant index.*/
	intptr_t lowRefInd;
	/**The high relevant index.*/
	intptr_t higRefInd;
	/**The number of skipped bases on the low reference side.*/
	intptr_t leadSoftClip;
	/**The number of skipped bases on the high reference side.*/
	intptr_t lagSoftClip;
	/**The cigar strings to report.*/
	std::vector< std::string > reportAligns;
	/**The start positions.*/
	std::vector<long> reportAlignStarts;
	/**The end positions.*/
	std::vector<long> reportAlignEnds;
	/**The log probability for each alignment.*/
	std::vector<double> reportAlignProbs;
	/**The scores.*/
	std::vector<int> reportAlignScores;
	/**The total log probability.*/
	double totalLogProb;
};

/**
 * This will realign a sequence.
 * @param rsr The setup.
 * @return Wheter there was a problem.
 */
int realignSequence(RealignSetupResult* rsr){
	//start iterating
	//package things up for the caller
		for(int i = 0; i<repNumRank; i++){
			std::vector<std::string>* curAligns = &(allAligns[i]);
			std::vector<long>* curAlignSt = &(allAlignStarts[i]);
			std::vector<long>* curAlignE = &(allAlignEnds[i]);
			std::vector<double>* curAlignP = &(allAlignProbs[i]);
			int numNeedAdd;
			if(maxRepCount == 0){
				numNeedAdd = curAligns->size();
			}
			else{
				numNeedAdd = maxRepCount - rsr->reportAligns.size();
				if(numNeedAdd == 0){ break; }
				if((unsigned)numNeedAdd > curAligns->size()){
					numNeedAdd = curAligns->size();
				}
			}
			rsr->reportAligns.insert(rsr->reportAligns.end(), curAligns->begin(), curAligns->begin() + numNeedAdd);
			rsr->reportAlignStarts.insert(rsr->reportAlignStarts.end(), curAlignSt->begin(), curAlignSt->begin() + numNeedAdd);
			rsr->reportAlignEnds.insert(rsr->reportAlignEnds.end(), curAlignE->begin(), curAlignE->begin() + numNeedAdd);
			rsr->reportAlignProbs.insert(rsr->reportAlignProbs.end(), curAlignP->begin(), curAlignP->begin() + numNeedAdd);
			rsr->reportAlignScores.insert(rsr->reportAlignScores.end(), (unsigned)numNeedAdd, foundScores[i]);
		}
	free(foundScores);
	if(seqToKill){free(seqToKill);}
	return 0;
}

/**
 * This will do anlaysis on a SAM entry.
 * @param sec The sam entry.
 * @return Whether there was a problem.
 */
int runSAMEntry(SAMEntryContext* sec){
	LiveSAMFileReader* samFil = sec->samFil;
	//quick testable cases (pass through header, skip supplemental and secondary)
		if(!(samFil->lastAlignQName)){
			return 0;
		}
		if(samFil->lastAlignFlag & 0x0904){
			return 0;
		}
	//look for its pair, if any
		std::string queryName(samFil->lastAlignQName);
		std::map< std::string, WaitingPairedEntry >::iterator waitPairIt = sec->waitingPairs->find(queryName);
	//get the bounds of the entry (expand the cigar)
		intptr_t tLowIndex = -1;
		intptr_t tHigIndex = -1;
		intptr_t numPreSkip = -1;
		intptr_t numPostSkip = -1;
		if(findCigarBounds(samFil, &tLowIndex, &tHigIndex, &numPreSkip, &numPostSkip, sec->errDump)){return 1;}
		if(tLowIndex < 0){ dumpAsIs(sec, waitPairIt); return 0; }
	//get all the stuff for the reference (reference sequence, problem regions and cost structure)
		std::string refNam(samFil->lastAlignRName);
		RefSeqIterator refIt;
		ProbRegIterator probMIt;
		CostIterator allRCIt;
		if(gatherReferenceInformation(&refNam, sec, &refIt, &probMIt, &allRCIt)){ dumpAsIs(sec, waitPairIt); return 0; }
	//reclaim soft clipped bases, scan against problematic regions, add overlap
		std::string* fullRefSeq = &(refIt->second);
		intptr_t expLowInd = tLowIndex;
		intptr_t expHigInd = tHigIndex;
		if(expandRealignSearchRegion(&expLowInd, &expHigInd, sec, numPreSkip, numPostSkip, probMIt, fullRefSeq, &refNam)){return 1;}
		if(expLowInd < 0){ dumpAsIs(sec, waitPairIt); return 0; }
	//let something else get the relevant alignments
		RealignSetupResult rsr;
		rsr.sec = sec;
		rsr.fullCF = allRCIt->second;
		rsr.fullRefSeq = fullRefSeq;
		rsr.lowRefInd = tLowIndex;
		rsr.higRefInd = tHigIndex;
		rsr.leadSoftClip = numPreSkip;
		rsr.lagSoftClip = numPostSkip;
		rsr.totalLogProb = 0.0;
		if(realignSequence(&rsr)){return 1;}
	//write out the result (or save it if paired with nothing prior)
		std::string pairInfo;
		if(waitPairIt != sec->waitingPairs->end()){
			//TODO
		}
		else if(samFil->lastAlignFlag & 0x01){
			//TODO
		}
		//TODO
	return 0;
}


